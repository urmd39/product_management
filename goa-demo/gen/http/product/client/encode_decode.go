// Code generated by goa v3.4.3, DO NOT EDIT.
//
// product HTTP client encoders and decoders
//
// Command:
// $ goa gen goa-demo/design

package client

import (
	"bytes"
	"context"
	product "goa-demo/gen/product"
	productviews "goa-demo/gen/product/views"
	"io/ioutil"
	"net/http"
	"net/url"

	goahttp "goa.design/goa/v3/http"
)

// BuildGetListProductRequest instantiates a HTTP request object with method
// and path set to call the "product" service "getListProduct" endpoint
func (c *Client) BuildGetListProductRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetListProductProductPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("product", "getListProduct", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeGetListProductResponse returns a decoder for responses returned by the
// product getListProduct endpoint. restoreBody controls whether the response
// body should be restored after having been read.
func DecodeGetListProductResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetListProductResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "getListProduct", err)
			}
			p := NewGetListProductStoredProductCollectionOK(body)
			view := resp.Header.Get("goa-view")
			vres := productviews.StoredProductCollection{Projected: p, View: view}
			if err = productviews.ValidateStoredProductCollection(vres); err != nil {
				return nil, goahttp.ErrValidationError("product", "getListProduct", err)
			}
			res := product.NewStoredProductCollection(vres)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("product", "getListProduct", resp.StatusCode, string(body))
		}
	}
}

// BuildGetProductRequest instantiates a HTTP request object with method and
// path set to call the "product" service "getProduct" endpoint
func (c *Client) BuildGetProductRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		id int
	)
	{
		p, ok := v.(*product.GetProductPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("product", "getProduct", "*product.GetProductPayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetProductProductPath(id)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("product", "getProduct", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetProductRequest returns an encoder for requests sent to the product
// getProduct server.
func EncodeGetProductRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*product.GetProductPayload)
		if !ok {
			return goahttp.ErrInvalidType("product", "getProduct", "*product.GetProductPayload", v)
		}
		values := req.URL.Query()
		if p.View != nil {
			values.Add("view", *p.View)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetProductResponse returns a decoder for responses returned by the
// product getProduct endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeGetProductResponse may return the following errors:
//	- "not_found" (type *product.NotFound): http.StatusNotFound
//	- error: internal error
func DecodeGetProductResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetProductResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "getProduct", err)
			}
			p := NewGetProductStoredProductOK(&body)
			view := resp.Header.Get("goa-view")
			vres := &productviews.StoredProduct{Projected: p, View: view}
			if err = productviews.ValidateStoredProduct(vres); err != nil {
				return nil, goahttp.ErrValidationError("product", "getProduct", err)
			}
			res := product.NewStoredProduct(vres)
			return res, nil
		case http.StatusNotFound:
			var (
				body GetProductNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "getProduct", err)
			}
			err = ValidateGetProductNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "getProduct", err)
			}
			return nil, NewGetProductNotFound(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("product", "getProduct", resp.StatusCode, string(body))
		}
	}
}

// BuildFilterProductRequest instantiates a HTTP request object with method and
// path set to call the "product" service "filterProduct" endpoint
func (c *Client) BuildFilterProductRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: FilterProductProductPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("product", "filterProduct", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeFilterProductRequest returns an encoder for requests sent to the
// product filterProduct server.
func EncodeFilterProductRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*product.FilterProductPayload)
		if !ok {
			return goahttp.ErrInvalidType("product", "filterProduct", "*product.FilterProductPayload", v)
		}
		values := req.URL.Query()
		values.Add("currency_unit", p.CurrencyUnit)
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeFilterProductResponse returns a decoder for responses returned by the
// product filterProduct endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeFilterProductResponse may return the following errors:
//	- "not_found" (type *product.NotFound): http.StatusNotFound
//	- error: internal error
func DecodeFilterProductResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body FilterProductResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "filterProduct", err)
			}
			p := NewFilterProductStoredProductCollectionOK(body)
			view := resp.Header.Get("goa-view")
			vres := productviews.StoredProductCollection{Projected: p, View: view}
			if err = productviews.ValidateStoredProductCollection(vres); err != nil {
				return nil, goahttp.ErrValidationError("product", "filterProduct", err)
			}
			res := product.NewStoredProductCollection(vres)
			return res, nil
		case http.StatusNotFound:
			var (
				body FilterProductNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "filterProduct", err)
			}
			err = ValidateFilterProductNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "filterProduct", err)
			}
			return nil, NewFilterProductNotFound(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("product", "filterProduct", resp.StatusCode, string(body))
		}
	}
}

// BuildCreateProductRequest instantiates a HTTP request object with method and
// path set to call the "product" service "createProduct" endpoint
func (c *Client) BuildCreateProductRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateProductProductPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("product", "createProduct", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateProductRequest returns an encoder for requests sent to the
// product createProduct server.
func EncodeCreateProductRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*product.Product)
		if !ok {
			return goahttp.ErrInvalidType("product", "createProduct", "*product.Product", v)
		}
		body := NewCreateProductRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("product", "createProduct", err)
		}
		return nil
	}
}

// DecodeCreateProductResponse returns a decoder for responses returned by the
// product createProduct endpoint. restoreBody controls whether the response
// body should be restored after having been read.
func DecodeCreateProductResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "createProduct", err)
			}
			return body, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("product", "createProduct", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateProductRequest instantiates a HTTP request object with method and
// path set to call the "product" service "updateProduct" endpoint
func (c *Client) BuildUpdateProductRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		id int
	)
	{
		p, ok := v.(*product.UpdateProductPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("product", "updateProduct", "*product.UpdateProductPayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateProductProductPath(id)}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("product", "updateProduct", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateProductRequest returns an encoder for requests sent to the
// product updateProduct server.
func EncodeUpdateProductRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*product.UpdateProductPayload)
		if !ok {
			return goahttp.ErrInvalidType("product", "updateProduct", "*product.UpdateProductPayload", v)
		}
		body := NewUpdateProductRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("product", "updateProduct", err)
		}
		return nil
	}
}

// DecodeUpdateProductResponse returns a decoder for responses returned by the
// product updateProduct endpoint. restoreBody controls whether the response
// body should be restored after having been read.
func DecodeUpdateProductResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateProductResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "updateProduct", err)
			}
			p := NewUpdateProductStoredProductOK(&body)
			view := resp.Header.Get("goa-view")
			vres := &productviews.StoredProduct{Projected: p, View: view}
			if err = productviews.ValidateStoredProduct(vres); err != nil {
				return nil, goahttp.ErrValidationError("product", "updateProduct", err)
			}
			res := product.NewStoredProduct(vres)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("product", "updateProduct", resp.StatusCode, string(body))
		}
	}
}

// BuildRemoveProductRequest instantiates a HTTP request object with method and
// path set to call the "product" service "removeProduct" endpoint
func (c *Client) BuildRemoveProductRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		id int
	)
	{
		p, ok := v.(*product.RemoveProductPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("product", "removeProduct", "*product.RemoveProductPayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: RemoveProductProductPath(id)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("product", "removeProduct", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeRemoveProductResponse returns a decoder for responses returned by the
// product removeProduct endpoint. restoreBody controls whether the response
// body should be restored after having been read.
func DecodeRemoveProductResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("product", "removeProduct", resp.StatusCode, string(body))
		}
	}
}

// unmarshalStoredProductResponseToProductviewsStoredProductView builds a value
// of type *productviews.StoredProductView from a value of type
// *StoredProductResponse.
func unmarshalStoredProductResponseToProductviewsStoredProductView(v *StoredProductResponse) *productviews.StoredProductView {
	res := &productviews.StoredProductView{
		ID:            v.ID,
		Name:          v.Name,
		CurrencyUnit:  v.CurrencyUnit,
		Description:   v.Description,
		UpdatedTime:   v.UpdatedTime,
		PurchasePrice: v.PurchasePrice,
		SellingPrice:  v.SellingPrice,
	}

	return res
}

// marshalProductProductToProductRequestBody builds a value of type
// *ProductRequestBody from a value of type *product.Product.
func marshalProductProductToProductRequestBody(v *product.Product) *ProductRequestBody {
	res := &ProductRequestBody{
		Name:          v.Name,
		CurrencyUnit:  v.CurrencyUnit,
		Description:   v.Description,
		UpdatedTime:   v.UpdatedTime,
		PurchasePrice: v.PurchasePrice,
		SellingPrice:  v.SellingPrice,
	}

	return res
}

// marshalProductRequestBodyToProductProduct builds a value of type
// *product.Product from a value of type *ProductRequestBody.
func marshalProductRequestBodyToProductProduct(v *ProductRequestBody) *product.Product {
	res := &product.Product{
		Name:          v.Name,
		CurrencyUnit:  v.CurrencyUnit,
		Description:   v.Description,
		UpdatedTime:   v.UpdatedTime,
		PurchasePrice: v.PurchasePrice,
		SellingPrice:  v.SellingPrice,
	}

	return res
}
