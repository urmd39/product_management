// Code generated by goa v3.4.3, DO NOT EDIT.
//
// product gRPC client encoders and decoders
//
// Command:
// $ goa gen goa-demo/design

package client

import (
	"context"
	productpb "goa-demo/gen/grpc/product/pb"
	product "goa-demo/gen/product"
	productviews "goa-demo/gen/product/views"

	goagrpc "goa.design/goa/v3/grpc"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

// BuildGetListProductFunc builds the remote method to invoke for "product"
// service "getListProduct" endpoint.
func BuildGetListProductFunc(grpccli productpb.ProductClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.GetListProduct(ctx, reqpb.(*productpb.GetListProductRequest), opts...)
		}
		return grpccli.GetListProduct(ctx, &productpb.GetListProductRequest{}, opts...)
	}
}

// DecodeGetListProductResponse decodes responses from the product
// getListProduct endpoint.
func DecodeGetListProductResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*productpb.StoredProductCollection)
	if !ok {
		return nil, goagrpc.ErrInvalidType("product", "getListProduct", "*productpb.StoredProductCollection", v)
	}
	res := NewGetListProductResult(message)
	vres := productviews.StoredProductCollection{Projected: res, View: view}
	if err := productviews.ValidateStoredProductCollection(vres); err != nil {
		return nil, err
	}
	return product.NewStoredProductCollection(vres), nil
}

// BuildGetProductFunc builds the remote method to invoke for "product" service
// "getProduct" endpoint.
func BuildGetProductFunc(grpccli productpb.ProductClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.GetProduct(ctx, reqpb.(*productpb.GetProductRequest), opts...)
		}
		return grpccli.GetProduct(ctx, &productpb.GetProductRequest{}, opts...)
	}
}

// EncodeGetProductRequest encodes requests sent to product getProduct endpoint.
func EncodeGetProductRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*product.GetProductPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("product", "getProduct", "*product.GetProductPayload", v)
	}
	if payload.View != nil {
		(*md).Append("view", *payload.View)
	}
	return NewGetProductRequest(payload), nil
}

// DecodeGetProductResponse decodes responses from the product getProduct
// endpoint.
func DecodeGetProductResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*productpb.GetProductResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("product", "getProduct", "*productpb.GetProductResponse", v)
	}
	res := NewGetProductResult(message)
	vres := &productviews.StoredProduct{Projected: res, View: view}
	if err := productviews.ValidateStoredProduct(vres); err != nil {
		return nil, err
	}
	return product.NewStoredProduct(vres), nil
}

// BuildFilterProductFunc builds the remote method to invoke for "product"
// service "filterProduct" endpoint.
func BuildFilterProductFunc(grpccli productpb.ProductClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.FilterProduct(ctx, reqpb.(*productpb.FilterProductRequest), opts...)
		}
		return grpccli.FilterProduct(ctx, &productpb.FilterProductRequest{}, opts...)
	}
}

// EncodeFilterProductRequest encodes requests sent to product filterProduct
// endpoint.
func EncodeFilterProductRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*product.FilterProductPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("product", "filterProduct", "*product.FilterProductPayload", v)
	}
	(*md).Append("currency_unit", payload.CurrencyUnit)
	return NewFilterProductRequest(), nil
}

// DecodeFilterProductResponse decodes responses from the product filterProduct
// endpoint.
func DecodeFilterProductResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*productpb.StoredProductCollection)
	if !ok {
		return nil, goagrpc.ErrInvalidType("product", "filterProduct", "*productpb.StoredProductCollection", v)
	}
	res := NewFilterProductResult(message)
	vres := productviews.StoredProductCollection{Projected: res, View: view}
	if err := productviews.ValidateStoredProductCollection(vres); err != nil {
		return nil, err
	}
	return product.NewStoredProductCollection(vres), nil
}

// BuildCreateProductFunc builds the remote method to invoke for "product"
// service "createProduct" endpoint.
func BuildCreateProductFunc(grpccli productpb.ProductClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.CreateProduct(ctx, reqpb.(*productpb.CreateProductRequest), opts...)
		}
		return grpccli.CreateProduct(ctx, &productpb.CreateProductRequest{}, opts...)
	}
}

// EncodeCreateProductRequest encodes requests sent to product createProduct
// endpoint.
func EncodeCreateProductRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*product.Product)
	if !ok {
		return nil, goagrpc.ErrInvalidType("product", "createProduct", "*product.Product", v)
	}
	return NewCreateProductRequest(payload), nil
}

// DecodeCreateProductResponse decodes responses from the product createProduct
// endpoint.
func DecodeCreateProductResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*productpb.CreateProductResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("product", "createProduct", "*productpb.CreateProductResponse", v)
	}
	res := NewCreateProductResult(message)
	return res, nil
}

// BuildUpdateProductFunc builds the remote method to invoke for "product"
// service "updateProduct" endpoint.
func BuildUpdateProductFunc(grpccli productpb.ProductClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.UpdateProduct(ctx, reqpb.(*productpb.UpdateProductRequest), opts...)
		}
		return grpccli.UpdateProduct(ctx, &productpb.UpdateProductRequest{}, opts...)
	}
}

// EncodeUpdateProductRequest encodes requests sent to product updateProduct
// endpoint.
func EncodeUpdateProductRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*product.UpdateProductPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("product", "updateProduct", "*product.UpdateProductPayload", v)
	}
	return NewUpdateProductRequest(payload), nil
}

// DecodeUpdateProductResponse decodes responses from the product updateProduct
// endpoint.
func DecodeUpdateProductResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*productpb.UpdateProductResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("product", "updateProduct", "*productpb.UpdateProductResponse", v)
	}
	res := NewUpdateProductResult(message)
	vres := &productviews.StoredProduct{Projected: res, View: view}
	if err := productviews.ValidateStoredProduct(vres); err != nil {
		return nil, err
	}
	return product.NewStoredProduct(vres), nil
}

// BuildRemoveProductFunc builds the remote method to invoke for "product"
// service "removeProduct" endpoint.
func BuildRemoveProductFunc(grpccli productpb.ProductClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.RemoveProduct(ctx, reqpb.(*productpb.RemoveProductRequest), opts...)
		}
		return grpccli.RemoveProduct(ctx, &productpb.RemoveProductRequest{}, opts...)
	}
}

// EncodeRemoveProductRequest encodes requests sent to product removeProduct
// endpoint.
func EncodeRemoveProductRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*product.RemoveProductPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("product", "removeProduct", "*product.RemoveProductPayload", v)
	}
	return NewRemoveProductRequest(payload), nil
}
